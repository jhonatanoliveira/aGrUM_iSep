/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

#include <iostream>
#include <wchar.h>

#include "Parser.h"
#include "Scanner.h"

namespace gum {
  namespace prm {
    namespace o3prm {

      void Parser::SynErr(int n) {
        if (errDist >= minErrDist)
          SynErr(scanner->filename(), la->line, la->col, n);

        errDist = 0;
      }

      const ErrorsContainer &Parser::errors(void) const { return __errors; }

      void Parser::Get() {
        for (;;) {
          t = la;
          la = scanner->Scan();

          if (la->kind <= maxT) {
            ++errDist;
            break;
          }

          if (dummyToken != t) {
            dummyToken->kind = t->kind;
            dummyToken->pos = t->pos;
            dummyToken->col = t->col;
            dummyToken->line = t->line;
            dummyToken->next = NULL;
            coco_string_delete(dummyToken->val);
            dummyToken->val = coco_string_create(t->val);
            t = dummyToken;
          }

          la = t;
        }
      }

      void Parser::Expect(int n) {
        if (la->kind == n)
          Get();
        else {
          SynErr(n);
        }
      }

      void Parser::ExpectWeak(int n, int follow) {
        if (la->kind == n)
          Get();
        else {
          SynErr(n);

          while (!StartOf(follow))
            Get();
        }
      }

      bool Parser::WeakSeparator(int n, int syFol, int repFol) {
        if (la->kind == n) {
          Get();
          return true;
        } else if (StartOf(repFol)) {
          return false;
        } else {
          SynErr(n);

          while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
            Get();
          }

          return StartOf(syFol);
        }
      }

      void Parser::O3PRM() {
        if (la->kind == 20 /* "package" */) {
          Package();
        }
        while (la->kind == 21 /* "import" */) {
          while (!(la->kind == _EOF || la->kind == 21 /* "import" */)) {
            SynErr(31);
            Get();
          }
          Import();
        }
        while (StartOf(1)) {
          while (!(StartOf(2))) {
            SynErr(32);
            Get();
          }
          Unit();
        }
        factory().popPackage();
      }

      void Parser::Package() {
        std::string name;
        while (!(la->kind == _EOF || la->kind == 20 /* "package" */)) {
          SynErr(33);
          Get();
        }
        Expect(20 /* "package" */);
        Ident(name);
        factory().pushPackage(name);
        __package = name;
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(34);
          Get();
        }
        Expect(_semicolon);
      }

      void Parser::Import() {
        std::string fileID;
        while (!(la->kind == _EOF || la->kind == 21 /* "import" */)) {
          SynErr(35);
          Get();
        }
        Expect(21 /* "import" */);
        ImportIdent(fileID);
        import(fileID);
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(36);
          Get();
        }
        Expect(_semicolon);
      }

      void Parser::Unit() {
        if (la->kind == _type) {
          Type();
        } else if (la->kind == _interface) {
          Interface();
        } else if (la->kind == _class) {
          Class();
        } else if (la->kind == _system) {
          System();
        } else
          SynErr(37);
      }

      void Parser::Ident(std::string &s) {
        std::stringstream sBuff;
        Expect(_word);
        sBuff << narrow(t->val);
        while (la->kind == _dot) {
          Get();
          Expect(_word);
          sBuff << "." << narrow(t->val);
        }
        s = sBuff.str();
      }

      void Parser::ImportIdent(std::string &s) {
        std::stringstream sBuff;
        Expect(_word);
        sBuff << narrow(t->val);
        while (la->kind == _dot) {
          Get();
          if (la->kind == _word) {
            Get();
          } else if (la->kind == 26 /* "*" */) {
            Get();
          } else
            SynErr(38);
          sBuff << "." << narrow(t->val);
        }
        s = sBuff.str();
      }

      void Parser::Type() {
        while (!(la->kind == _EOF || la->kind == _type)) {
          SynErr(39);
          Get();
        }
        Expect(_type);
        Expect(_word);
        std::string name, extends, l, s;
        name = narrow(t->val);
        if (la->kind == _extends) {
          Get();
          Ident(extends);
        }
        TRY2(factory().startDiscreteType(name, extends),
             "Can not create type " + name)
        Label(l);
        if (la->kind == _colon) {
          Get();
          Label(s);
        }
        TRY2(factory().addLabel(l, s), "Can not add label " + l)
        while (la->kind == _comma) {
          s = "";
          ExpectWeak(_comma, 3);
          Label(l);
          if (la->kind == _colon) {
            Get();
            Label(s);
          }
          TRY2(factory().addLabel(l, s), "Can not add label " + l)
        }
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(40);
          Get();
        }
        Expect(_semicolon);
        TRY2(factory().endDiscreteType(), "Can not create type " + name)
      }

      void Parser::Interface() {
        while (!(la->kind == _EOF || la->kind == _interface)) {
          SynErr(41);
          Get();
        }
        Expect(_interface);
        Expect(_word);
        std::string interface, extends;
        interface = narrow(t->val);
        if (la->kind == _extends) {
          Get();
          Ident(extends);
        }
        while (!(la->kind == _EOF || la->kind == 22 /* "{" */)) {
          SynErr(42);
          Get();
        }
        Expect(22 /* "{" */);
        TRY2(factory().startInterface(interface, extends),
             "Can not create interface " + interface)
        while (la->kind == _word) {
          std::string type, name;
          Ident(type);
          if (la->kind == 23 /* "[" */) {
            Get();
            Expect(24 /* "]" */);
            Expect(_word);
            name = narrow(t->val);
            bool array = true;
            Reference(type, name, array);
          } else if (la->kind == _word) {
            Get();
            name = narrow(t->val);
            bool array = false;
            if (isClassOrInterface(type)) {
              Reference(type, name, array);
            } else if (la->kind == _semicolon) {
              while (!(la->kind == _EOF || la->kind == _semicolon)) {
                SynErr(43);
                Get();
              }
              Get();
              TRY2(factory().addAttribute(type, name),
                   "Can not add attribute " + name)
            } else
              SynErr(44);
          } else
            SynErr(45);
        }
        while (!(la->kind == _EOF || la->kind == 25 /* "}" */)) {
          SynErr(46);
          Get();
        }
        Expect(25 /* "}" */);
        TRY2(factory().endInterface(), "Can not create interface " + interface)
      }

      void Parser::Class() {
        Expect(_class);
        Expect(_word);
        std::string c, super;
        c = narrow(t->val);
        if (la->kind == _extends) {
          Get();
          Ident(super);
        }
        gum::Set<std::string> set;
        if (la->kind == _implements) {
          std::string i;
          Get();
          Ident(i);
          set.insert(i);
          while (la->kind == _comma) {
            Get();
            Ident(i);
            set.insert(i);
          }
        }
        while (!(la->kind == _EOF || la->kind == 22 /* "{" */)) {
          SynErr(47);
          Get();
        }
        Expect(22 /* "{" */);
        TRY2(factory().startClass(c, super, (set.empty() ? 0 : &set)),
             "Can not create class " + c)
        while (la->kind == _word) {
          std::string type, name;
          bool array = false;
          Ident(type);
          if (la->kind == 23 /* "[" */) {
            Get();
            Expect(24 /* "]" */);
            Expect(_word);
            name = narrow(t->val);
            array = true;
            Reference(type, name, array);
          } else if (la->kind == _word) {
            Get();
            name = narrow(t->val);
            array = false;
            if (la->kind == _semicolon || la->kind == _default) {
              RefOrParam(type, name, array);
            } else if (la->kind == _dependson || la->kind == 22 /* "{" */) {
              Attribute(type, name);
            } else if (la->kind == 27 /* "=" */) {
              Aggregate(type, name);
            } else if (la->kind == 28 /* "~" */) {
              Functions(type, name);
            } else
              SynErr(48);
          } else
            SynErr(49);
        }
        while (!(la->kind == _EOF || la->kind == 25 /* "}" */)) {
          SynErr(50);
          Get();
        }
        Expect(25 /* "}" */);
        TRY2(factory().endClass(), "Can not create class " + c)
      }

      void Parser::System() {
        Expect(_system);
        Expect(_word);
        TRY(factory().startSystem(narrow(t->val)))
        Expect(22 /* "{" */);
        while (la->kind == _word) {
          std::string l1, r1;
          Ident(l1);
          if (la->kind == 23 /* "[" */) {
            ArrayDecl(l1);
          } else if (la->kind == _word) {
            Get();
            TRY(factory().addInstance(l1, narrow(t->val)))
          } else if (la->kind == 29 /* "+=" */) {
            Get();
            Ident(r1);
            if (factory().isArrayInCurrentSystem(l1)) {
              TRY(factory().incArray(l1, r1))
            } else {
              TRY(factory().setReferenceSlot(l1, r1))
            }

          } else if (la->kind == 27 /* "=" */) {
            Get();
            Ident(r1);
            TRY(try { factory().setReferenceSlot(l1, r1); } catch (
                gum::Exception &e) {
              size_t pos = l1.find_last_of('.');
              if (pos != std::string::npos) {
                std::string i = l1.substr(0, pos);
                std::string p = l1.substr(pos + 1, std::string::npos);
                factory().setParameter(i, p, r1);
              }
            })

          } else
            SynErr(51);
          Expect(_semicolon);
        }
        while (!(la->kind == _EOF || la->kind == 25 /* "}" */)) {
          SynErr(52);
          Get();
        }
        Expect(25 /* "}" */);
        TRY(factory().endSystem())
      }

      void Parser::Label(std::string &s) {
        if (la->kind == _word) {
          Get();
          s = narrow(t->val);
        } else if (la->kind == _integer || la->kind == _float) {
          float val;
          Number(val);
          std::stringstream sBuff;
          sBuff << val;
          s = sBuff.str();
        } else
          SynErr(53);
      }

      void Parser::Reference(std::string type, std::string name, bool array) {
        Expect(_semicolon);
        TRY2(factory().addReferenceSlot(type, name, array),
             "Can not add reference " + name)
      }

      void Parser::RefOrParam(std::string type, std::string name, bool array) {
        if (isClassOrInterface(type)) {
          Reference(type, name, array);
        } else if (la->kind == _semicolon || la->kind == _default) {
          Parameter(type, name);
        } else
          SynErr(54);
      }

      void Parser::Attribute(std::string type, std::string name) {
        std::string p;
        bool error = false;
        TRY3(factory().startAttribute(type, name),
             "Can not create attribute " + name, error)
        if (la->kind == _dependson) {
          Get();
          CastIdent(p);
          TRY3(factory().addParent(p), "Can not add parent " + p, error)
          while (la->kind == _comma) {
            Get();
            CastIdent(p);
            TRY3(factory().addParent(p), "Can not add parent " + p, error)
          }
        }
        Expect(22 /* "{" */);
        if (la->kind == 23 /* "[" */) {
          Get();
          std::vector<float> cpt;
          float f;
          Number(f);
          cpt.push_back(f);
          while (WeakSeparator(_comma, 5, 4)) {
            Number(f);
            cpt.push_back(f);
          }
          Expect(24 /* "]" */);
          TRY3(factory().setRawCPFByFloatColumns(cpt), "Problem with CPF of " + name,
               error)
        } else if (la->kind == _word || la->kind == 26 /* "*" */) {
          CPTRule(error);
          while (la->kind == _word || la->kind == 26 /* "*" */) {
            CPTRule(error);
          }
        } else
          SynErr(55);
        Expect(25 /* "}" */);
        TRY3(factory().endAttribute(), "Can not create attribute " + name, error)
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(56);
          Get();
        }
        Expect(_semicolon);
      }

      void Parser::Aggregate(std::string type, std::string name) {
        std::string func, s;
        std::vector<std::string> chains, labels;
        Expect(27 /* "=" */);
        Expect(_word);
        func = narrow(t->val);
        Expect(_LEFT_CAST);
        AggChains(chains);
        ExpectWeak(_comma, 6);
        AggLabels(labels);
        Expect(_RIGHT_CAST);
        TRY2(factory().addAggregator(name, func, chains, labels),
             "Can not create aggregator " + name)
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(57);
          Get();
        }
        Expect(_semicolon);
      }

      void Parser::Functions(std::string type, std::string name) {
        if (type != "boolean") {
          TRY(throw gum::OperationNotAllowed("noisy-or attributes must be booleans"))
        }
        Expect(28 /* "~" */);
        Expect(_noisyOr);
        Expect(_LEFT_CAST);
        std::vector<std::string> chains, labels;
        std::vector<float> numbers;
        float leak = 0.0;
        AggChains(chains);
        Expect(_comma);
        NumberList(numbers);
        if (la->kind == _comma) {
          Get();
          Number(leak);
          if (la->kind == _comma) {
            Get();
            AggLabels(labels);
          }
        }
        Expect(_RIGHT_CAST);
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(58);
          Get();
        }
        Expect(_semicolon);
        TRY2(factory().addNoisyOrCompound(name, chains, numbers, leak, labels),
             "Can not add function" + name)
      }

      void Parser::Parameter(std::string type, std::string name) {
        std::string l;
        if (la->kind == _default) {
          Get();
          Label(l);
        }
        TRY2(factory().addParameter(type, name, l), "Can not add parameter " + name)
        Expect(_semicolon);
      }

      void Parser::CastIdent(std::string &s) {
        std::string cast, open(gum::prm::PRMObject::LEFT_CAST()),
            close(gum::prm::PRMObject::RIGHT_CAST());
        std::stringstream sBuff;
        if (la->kind == _LEFT_CAST) {
          Get();
          Ident(cast);
          Expect(_RIGHT_CAST);
          sBuff << open << cast << close;
        }
        Expect(_word);
        sBuff << narrow(t->val);
        while (la->kind == _dot) {
          cast = "";
          Get();
          sBuff << '.';
          if (la->kind == _LEFT_CAST) {
            Get();
            Ident(cast);
            Expect(_RIGHT_CAST);
            sBuff << open << cast << close;
          }
          Expect(_word);
          sBuff << narrow(t->val);
        }
        s = sBuff.str();
      }

      void Parser::Number(float &val) {
        if (la->kind == _integer) {
          Get();
          val = coco_atoi(t->val);
        } else if (la->kind == _float) {
          Get();
          val = coco_atof(t->val);
        } else
          SynErr(59);
      }

      void Parser::CPTRule(bool &error) {
        std::vector<std::string> labels;
        std::vector<float> values;
        std::string s;
        float f;
        CPTRuleValue(s);
        labels.push_back(s);
        while (WeakSeparator(_comma, 8, 7)) {
          CPTRuleValue(s);
          labels.push_back(s);
        }
        Expect(_colon);
        Number(f);
        values.push_back(f);
        while (WeakSeparator(_comma, 5, 9)) {
          Number(f);
          values.push_back(f);
        }
        while (!(la->kind == _EOF || la->kind == _semicolon)) {
          SynErr(60);
          Get();
        }
        Expect(_semicolon);
        TRY3(factory().setCPFByFloatRule(labels, values),
             std::string("Problem with CPF"), error)
      }

      void Parser::CPTRuleValue(std::string &s) {
        if (la->kind == _word) {
          Get();
          s = narrow(t->val);
        } else if (la->kind == 26 /* "*" */) {
          Get();
          s = "*";
        } else
          SynErr(61);
      }

      void Parser::AggChains(std::vector<std::string> &chains) {
        if (la->kind == _word || la->kind == _LEFT_CAST) {
          std::string s;
          CastIdent(s);
          chains.push_back(s);
        } else if (la->kind == 23 /* "[" */) {
          Get();
          std::string s;
          CastIdent(s);
          chains.push_back(s);
          while (WeakSeparator(_comma, 10, 4)) {
            CastIdent(s);
            chains.push_back(s);
          }
          Expect(24 /* "]" */);
        } else if (la->kind == 22 /* "{" */) {
          Get();
          std::string s;
          CastIdent(s);
          chains.push_back(s);
          while (WeakSeparator(_comma, 10, 11)) {
            CastIdent(s);
            chains.push_back(s);
          }
          while (!(la->kind == _EOF || la->kind == 25 /* "}" */)) {
            SynErr(62);
            Get();
          }
          Expect(25 /* "}" */);
        } else
          SynErr(63);
      }

      void Parser::AggLabels(std::vector<std::string> &labels) {
        if (la->kind == _word) {
          Get();
          labels.push_back(narrow(t->val));
        } else if (la->kind == 23 /* "[" */) {
          Get();
          Expect(_word);
          labels.push_back(narrow(t->val));
          while (la->kind == _comma) {
            Get();
            Expect(_word);
            labels.push_back(narrow(t->val));
          }
          Expect(24 /* "]" */);
        } else if (la->kind == 22 /* "{" */) {
          Get();
          Expect(_word);
          labels.push_back(narrow(t->val));
          while (WeakSeparator(_comma, 12, 11)) {
            Expect(_word);
            labels.push_back(narrow(t->val));
          }
          while (!(la->kind == _EOF || la->kind == 25 /* "}" */)) {
            SynErr(64);
            Get();
          }
          Expect(25 /* "}" */);
        } else
          SynErr(65);
      }

      void Parser::NumberList(std::vector<float> &numbers) {
        float f;
        if (la->kind == _integer || la->kind == _float) {
          Number(f);
          numbers.push_back(f);
        } else if (la->kind == 23 /* "[" */) {
          Get();
          Number(f);
          numbers.push_back(f);
          while (WeakSeparator(_comma, 5, 4)) {
            Number(f);
            numbers.push_back(f);
          }
          Expect(24 /* "]" */);
        } else
          SynErr(66);
      }

      void Parser::ArrayDecl(std::string l1) {
        std::string r1;
        std::stringstream sBuff;
        sBuff << l1;
        int size = 0;
        Expect(23 /* "[" */);
        if (la->kind == _integer) {
          Get();
          sBuff << '[' << narrow(t->val) << ']';
          size = coco_atoi(t->val);
        }
        Expect(24 /* "]" */);
        if (la->kind == _word) {
          Get();
          TRY(factory().addArray(l1, narrow(t->val), size))
        } else if (la->kind == _dot) {
          Get();
          Expect(_word);
          std::string l2 = narrow(t->val);
          if (la->kind == 29 /* "+=" */) {
            Get();
            Ident(r1);
            TRY(factory().setReferenceSlot(sBuff.str(), l2, r1))
          } else if (la->kind == 27 /* "=" */) {
            Get();
            Ident(r1);
            TRY(try { factory().setReferenceSlot(sBuff.str(), l2, r1); } catch (
                gum::Exception &e) { factory().setParameter(sBuff.str(), l2, r1); })
          } else
            SynErr(67);
        } else
          SynErr(68);
      }

      // If the user declared a method Init and a mehtod Destroy they should
      // be called in the contructur and the destructor respctively.
      //
      // The following templates are used to recognize if the user declared
      // the methods Init and Destroy.

      template <typename T> struct ParserInitExistsRecognizer {
        template <typename U, void (U::*)() = &U::Init>
        struct ExistsIfInitIsDefinedMarker {};

        struct InitIsMissingType {
          char dummy1;
        };

        struct InitExistsType {
          char dummy1;
          char dummy2;
        };

        // exists always
        template <typename U> static InitIsMissingType is_here(...);

        // exist only if ExistsIfInitIsDefinedMarker is defined
        template <typename U>
        static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U> *);

        enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
      };

      template <typename T> struct ParserDestroyExistsRecognizer {
        template <typename U, void (U::*)() = &U::Destroy>
        struct ExistsIfDestroyIsDefinedMarker {};

        struct DestroyIsMissingType {
          char dummy1;
        };

        struct DestroyExistsType {
          char dummy1;
          char dummy2;
        };

        // exists always
        template <typename U> static DestroyIsMissingType is_here(...);

        // exist only if ExistsIfDestroyIsDefinedMarker is defined
        template <typename U>
        static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U> *);

        enum {
          DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType))
        };
      };

      // The folloing templates are used to call the Init and Destroy methods if they
      // exist.

      // Generic case of the ParserInitCaller, gets used if the Init method is
      // missing
      template <typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
      struct ParserInitCaller {
        static void CallInit(T *t) {
          // nothing to do
        }
      };

      // True case of the ParserInitCaller, gets used if the Init method exists
      template <typename T> struct ParserInitCaller<T, true> {
        static void CallInit(T *t) { t->Init(); }
      };

      // Generic case of the ParserDestroyCaller, gets used if the Destroy method is
      // missing
      template <typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
      struct ParserDestroyCaller {
        static void CallDestroy(T *t) {
          // nothing to do
        }
      };

      // True case of the ParserDestroyCaller, gets used if the Destroy method exists
      template <typename T> struct ParserDestroyCaller<T, true> {
        static void CallDestroy(T *t) { t->Destroy(); }
      };
      void Parser::Parse() {
        t = NULL;
        la = dummyToken = new Token();
        la->val = coco_string_create(L"Dummy Token");
        Get();
        O3PRM();
      }

      Parser::Parser(Scanner *scanner) {
        maxT = 30;

        ParserInitCaller<Parser>::CallInit(this);
        dummyToken = NULL;
        t = la = NULL;
        minErrDist = 2;
        errDist = minErrDist;
        this->scanner = scanner;
      }

      bool Parser::StartOf(int s) {
        const bool T = true;
        const bool x = false;

        static bool set[13][32] = {{T, x, x, x, x, x, x, x, T, T, T, T, x, T, x, x,
                                    x, x, x, x, T, T, T, x, x, T, x, x, x, x, x, x},
                                   {x, x, x, x, x, x, x, x, x, T, T, T, x, T, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {T, x, x, x, x, x, x, x, x, T, T, T, x, T, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {T, T, T, T, x, x, x, x, T, T, T, T, x, T, x, x,
                                    x, x, x, x, T, T, T, x, x, T, x, x, x, x, x, x},
                                   {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x},
                                   {x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {T, x, x, T, x, x, x, x, T, T, T, T, x, T, x, x,
                                    x, x, x, x, T, T, T, T, x, T, x, x, x, x, x, x},
                                   {x, x, x, x, x, x, x, T, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {x, x, x, T, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x},
                                   {x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {x, x, x, T, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x},
                                   {x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x},
                                   {x, x, x, T, x, x, x, x, x, x, x, x, x, x, x, x,
                                    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x}};

        return set[s][la->kind];
      }

      Parser::~Parser() {
        ParserDestroyCaller<Parser>::CallDestroy(this);
        delete dummyToken;
      }
      void Parser::SemErr(const wchar_t *msg) {
        if (errDist >= minErrDist)
          __errors.Error(scanner->filename(), t->line, t->col, msg);

        errDist = 0;
      }

      void Parser::Warning(const wchar_t *msg) {
        __errors.Warning(scanner->filename(), t->line, t->col, msg);
      }

      void Parser::SynErr(const std::wstring &filename, int line, int col, int n) {
        wchar_t *s;

        switch (n) {
          case 0:
            s = coco_string_create(L"EOF expected");
            break;
          case 1:
            s = coco_string_create(L"integer expected");
            break;
          case 2:
            s = coco_string_create(L"float expected");
            break;
          case 3:
            s = coco_string_create(L"word expected");
            break;
          case 4:
            s = coco_string_create(L"eol expected");
            break;
          case 5:
            s = coco_string_create(L"dot expected");
            break;
          case 6:
            s = coco_string_create(L"comma expected");
            break;
          case 7:
            s = coco_string_create(L"colon expected");
            break;
          case 8:
            s = coco_string_create(L"semicolon expected");
            break;
          case 9:
            s = coco_string_create(L"type expected");
            break;
          case 10:
            s = coco_string_create(L"class expected");
            break;
          case 11:
            s = coco_string_create(L"interface expected");
            break;
          case 12:
            s = coco_string_create(L"extends expected");
            break;
          case 13:
            s = coco_string_create(L"system expected");
            break;
          case 14:
            s = coco_string_create(L"dependson expected");
            break;
          case 15:
            s = coco_string_create(L"default expected");
            break;
          case 16:
            s = coco_string_create(L"implements expected");
            break;
          case 17:
            s = coco_string_create(L"noisyOr expected");
            break;
          case 18:
            s = coco_string_create(L"LEFT_CAST expected");
            break;
          case 19:
            s = coco_string_create(L"RIGHT_CAST expected");
            break;
          case 20:
            s = coco_string_create(L"\"package\" expected");
            break;
          case 21:
            s = coco_string_create(L"\"import\" expected");
            break;
          case 22:
            s = coco_string_create(L"\"{\" expected");
            break;
          case 23:
            s = coco_string_create(L"\"[\" expected");
            break;
          case 24:
            s = coco_string_create(L"\"]\" expected");
            break;
          case 25:
            s = coco_string_create(L"\"}\" expected");
            break;
          case 26:
            s = coco_string_create(L"\"*\" expected");
            break;
          case 27:
            s = coco_string_create(L"\"=\" expected");
            break;
          case 28:
            s = coco_string_create(L"\"~\" expected");
            break;
          case 29:
            s = coco_string_create(L"\"+=\" expected");
            break;
          case 30:
            s = coco_string_create(L"??? expected");
            break;
          case 31:
            s = coco_string_create(L"this symbol not expected in O3PRM");
            break;
          case 32:
            s = coco_string_create(L"this symbol not expected in O3PRM");
            break;
          case 33:
            s = coco_string_create(L"this symbol not expected in Package");
            break;
          case 34:
            s = coco_string_create(L"this symbol not expected in Package");
            break;
          case 35:
            s = coco_string_create(L"this symbol not expected in Import");
            break;
          case 36:
            s = coco_string_create(L"this symbol not expected in Import");
            break;
          case 37:
            s = coco_string_create(L"invalid Unit");
            break;
          case 38:
            s = coco_string_create(L"invalid ImportIdent");
            break;
          case 39:
            s = coco_string_create(L"this symbol not expected in Type");
            break;
          case 40:
            s = coco_string_create(L"this symbol not expected in Type");
            break;
          case 41:
            s = coco_string_create(L"this symbol not expected in Interface");
            break;
          case 42:
            s = coco_string_create(L"this symbol not expected in Interface");
            break;
          case 43:
            s = coco_string_create(L"this symbol not expected in Interface");
            break;
          case 44:
            s = coco_string_create(L"invalid Interface");
            break;
          case 45:
            s = coco_string_create(L"invalid Interface");
            break;
          case 46:
            s = coco_string_create(L"this symbol not expected in Interface");
            break;
          case 47:
            s = coco_string_create(L"this symbol not expected in Class");
            break;
          case 48:
            s = coco_string_create(L"invalid Class");
            break;
          case 49:
            s = coco_string_create(L"invalid Class");
            break;
          case 50:
            s = coco_string_create(L"this symbol not expected in Class");
            break;
          case 51:
            s = coco_string_create(L"invalid System");
            break;
          case 52:
            s = coco_string_create(L"this symbol not expected in System");
            break;
          case 53:
            s = coco_string_create(L"invalid Label");
            break;
          case 54:
            s = coco_string_create(L"invalid RefOrParam");
            break;
          case 55:
            s = coco_string_create(L"invalid Attribute");
            break;
          case 56:
            s = coco_string_create(L"this symbol not expected in Attribute");
            break;
          case 57:
            s = coco_string_create(L"this symbol not expected in Aggregate");
            break;
          case 58:
            s = coco_string_create(L"this symbol not expected in Functions");
            break;
          case 59:
            s = coco_string_create(L"invalid Number");
            break;
          case 60:
            s = coco_string_create(L"this symbol not expected in CPTRule");
            break;
          case 61:
            s = coco_string_create(L"invalid CPTRuleValue");
            break;
          case 62:
            s = coco_string_create(L"this symbol not expected in AggChains");
            break;
          case 63:
            s = coco_string_create(L"invalid AggChains");
            break;
          case 64:
            s = coco_string_create(L"this symbol not expected in AggLabels");
            break;
          case 65:
            s = coco_string_create(L"invalid AggLabels");
            break;
          case 66:
            s = coco_string_create(L"invalid NumberList");
            break;
          case 67:
            s = coco_string_create(L"invalid ArrayDecl");
            break;
          case 68:
            s = coco_string_create(L"invalid ArrayDecl");
            break;

          default: {
            wchar_t format[20];
            coco_swprintf(format, 20, L"error %d", n);
            s = coco_string_create(format);
          } break;
        }

        // wprintf(L"-- line %d col %d: %ls\n", line, col, s);
        std::wstring ss = L"Syntax error : " + std::wstring(s);
        __errors.Error(filename, line, col, ss.c_str());
        coco_string_delete(s);
      }

    } // namespace
  }   // namespace
} // namespace
