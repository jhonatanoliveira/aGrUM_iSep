/***************************************************************************
 *  aGrUM modified frames and atg files for cocoR
 *   Copyright (c) 2005 by Christophe GONZALES and Pierre-Henri WUILLEMIN  *
 *   {prenom.nom}_at_lip6.fr
***************************************************************************/
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

#if !defined(gum_prm_o3prm_COCO_PARSER_H__)
#define gum_prm_o3prm_COCO_PARSER_H__

#include <string>
#include <sstream>
#include <algorithm>
#include <fstream>

#include <agrum/core/utils_dir.h>
#include <agrum/PRM/IPRMFactory.h>

#undef TRY
// Redefine try / catch to add a semantic error when errors are raised.
#define TRY(inst)                                                                   \
  try {                                                                             \
    inst;                                                                           \
  } catch (gum::Exception & e) {                                                    \
    SemErr(e.errorContent());                                                       \
  }
#define TRY2(inst, msg)                                                             \
  try {                                                                             \
    inst;                                                                           \
  } catch (gum::Exception & e) {                                                    \
    SemErr(msg + " (" + e.errorContent() + ").");                                   \
  }
#define TRY3(inst, msg, error)                                                      \
  try {                                                                             \
    if (!error) {                                                                   \
      inst;                                                                         \
    }                                                                               \
  } catch (gum::Exception & e) {                                                    \
    SemErr(msg + " (" + e.errorContent() + ").");                                   \
    error = true;                                                                   \
  }

#include <iostream>
#include <string>
#include <fstream>
#include "Scanner.h"

namespace gum {
  namespace prm {
    namespace o3prm {

      class Parser {
        private:
        enum {
          _EOF = 0,
          _integer = 1,
          _float = 2,
          _word = 3,
          _eol = 4,
          _dot = 5,
          _comma = 6,
          _colon = 7,
          _semicolon = 8,
          _type = 9,
          _class = 10,
          _interface = 11,
          _extends = 12,
          _system = 13,
          _dependson = 14,
          _default = 15,
          _implements = 16,
          _noisyOr = 17,
          _LEFT_CAST = 18,
          _RIGHT_CAST = 19
        };
        int maxT;

        Token *dummyToken;
        int errDist;
        int minErrDist;

        void SynErr(int n);
        void Get();
        void Expect(int n);
        bool StartOf(int s);
        void ExpectWeak(int n, int follow);
        bool WeakSeparator(int n, int syFol, int repFol);

        ErrorsContainer __errors;

        public:
        Scanner *scanner;

        Token *t;  // last recognized token
        Token *la; // lookahead token

        private:
        gum::prm::IPRMFactory *__factory;
        std::vector<std::string> __class_path;
        gum::Set<std::string> __imports;
        std::string __package;
        gum::Directory __current_directory;

        // Convert std::string to wstring.
        void SemErr(std::string s) { SemErr(widen(s).c_str()); }

        // Return true if type is a class or an interface.
        bool isClassOrInterface(std::string type) {
          return factory().isClassOrInterface(type);
        }

        void importDirID(std::string dirID) {
          std::string dirname = dirID, dirpath;
          bool dirFound = false;

          // Create filename
          replace(dirname.begin(), dirname.end(), '.', '/');
          dirname += "/";

          // Search in current directory.
          if (__current_directory.isValid()) {
            dirpath = __current_directory.absolutePath() + dirname;
            dirFound = Directory::isDir(dirpath);
          }

          // Search in root package directory.
          if (!dirFound && !__package.empty()) {
            int cpt = std::count(__package.begin(), __package.end(), '.');
            std::string cd = __current_directory.absolutePath();
            size_t index =
                cd.find_last_of('/', cd.size() - 2); // handle if cwd ends with a '/'
            for (int i = 0; index != std::string::npos && i < cpt; i++)
              index = cd.find_last_of('/', index - 1);

            if (index != std::string::npos) {
              std::string rootDir = cd.substr(0, index + 1); // with '/' at end
              dirpath = rootDir + dirname;
              dirFound = Directory::isDir(dirpath);
            }
          }

          // Search filename in each path stored in __class_path
          if (!dirFound) {
            for (const auto &path : __class_path) {
              // Construct complete filePath
              dirpath = path + dirname;
              dirFound = Directory::isDir(dirpath);
              if (dirFound)
                break;
            }
          }

          // If it is found, import all files in.
          if (dirFound)
            importDir(dirpath);
          // If import filename has not been found, add an error.
          else
            SemErr("import not found");
        }

        void importDir(std::string dirpath) {
          // Update current directory
          Directory oldCurrentDirectory = __current_directory;
          __current_directory = Directory(dirpath);

          for (const auto &entry : __current_directory.entries()) {
            if (entry[0] == '.') //"." or ".." or ".svn" or any hidden directories...
              continue;

            if (Directory::isDir(dirpath + entry))
              importDir(dirpath + entry + "/");
            else if (entry.substr(entry.find_last_of('.')) == ".o3prm") // if .o3prm
              importFile(dirpath + entry);
          }

          // Reset previous current directory
          __current_directory = oldCurrentDirectory;
        }

        void importFile(std::string filepath) {
          // If we have already import this file, skip it.
          // (like filepath is always absolute, there is no conflict)
          if (__imports.exists(filepath))
            return;
          // Remember we have found it.
          __imports.insert(filepath);

          // We parse it
          Scanner s(filepath.c_str());
          Parser p(&s);
          p.setFactory(__factory);
          p.setClassPath(__class_path);
          p.setImports(__imports);
          p.setCurrentDirectory(filepath.substr(0, filepath.find_last_of('/') + 1));
          p.Parse();

          // We add file imported in p to file imported here.
          for (const auto &import : p.getImports())
            if (not __imports.exists(import))
              __imports.insert(import);

          // We add warnings and errors to this
          __errors += p.__errors;
        }

        void import(std::string fileID) {
          // Si on inclut un r?(C)pertoire entier
          size_t starIndex = fileID.find_last_of('*');
          if (starIndex != std::string::npos) {
            return importDirID(fileID.substr(0, starIndex - 1));
          }

          std::string filename = fileID, filepath;
          std::ifstream file_test;
          bool fileFound = false;

          // Create filename
          replace(filename.begin(), filename.end(), '.', '/');
          filename += ".o3prm";

          // Search in current directory.
          if (__current_directory.isValid()) {
            filepath = __current_directory.absolutePath() + filename;
            file_test.open(filepath.c_str());
            if (file_test.is_open()) {
              file_test.close();
              fileFound = true;
            }
          }

          // Search in root package directory.
          if (!fileFound && !__package.empty()) {
            int cpt = std::count(__package.begin(), __package.end(), '.');
            std::string cd = __current_directory.absolutePath();
            size_t index =
                cd.find_last_of('/', cd.size() - 2); // handle if cwd ends with a '/'
            for (int i = 0; index != std::string::npos && i < cpt; i++)
              index = cd.find_last_of('/', index - 1);

            if (index != std::string::npos) {
              std::string rootDir = cd.substr(0, index + 1); // with '/' at end
              filepath = rootDir + filename;
              file_test.open(filepath.c_str());
              if (file_test.is_open()) {
                file_test.close();
                fileFound = true;
              }
            }
          }

          // Search filename in each path stored in __class_path
          for (const auto &path : __class_path) {
            // Construct complete filePath
            filepath = path + filename;

            // We try to open it
            file_test.open(filepath.c_str());
            if (file_test.is_open()) {
              file_test.close();
              fileFound = true;
            }
          }

          // If it is found, import it.
          if (fileFound)
            importFile(filepath);
          else
            SemErr("import not found");
        }

        // Set files already import in factory.
        void setImports(const gum::Set<std::string> &imports) {
          __imports = imports;
        }

        // Add these import to this parser.
        void addImports(const gum::Set<std::string> &imports) {
          for (const auto &import : imports)
            if (not __imports.exists(import))
              __imports.insert(import);
        }

        public:
        // Set the parser factory.
        void setFactory(gum::prm::IPRMFactory *f) { __factory = f; }

        // Retrieve the factory.
        gum::prm::IPRMFactory &factory() {
          if (__factory) {
            return *__factory;
          }
          GUM_ERROR(OperationNotAllowed,
                    "Please set a factory for scanning BIF file...");
        }

        // Set the paths to search for imports. Must ended with a '/'.
        void setClassPath(const std::vector<std::string> &class_path) {
          __class_path = class_path;
        }

        // Must be an absolute path
        void setCurrentDirectory(const std::string &cd) {
          __current_directory = Directory(cd);
          if (!__current_directory.isValid())
            Warning(widen("gum::o3prm::Parser::setCurrentDirectory : " + cd +
                          " is not a valid directory.").c_str());
        }

        // Get files imports.
        const gum::Set<std::string> &getImports() const { return __imports; }

        // Add this import to this parser.
        void addImport(const std::string &import) {
          if (not __imports.exists(import)) {
            __imports.insert(import);
          }
        }

        //##############################################################################
        //
        //                              SCANNER RULES
        //
        //##############################################################################

        //________________________

        Parser(Scanner *scanner);
        ~Parser();
        void SemErr(const wchar_t *msg);
        void SynErr(const std::wstring &filename, int line, int col, int n);
        void Warning(const wchar_t *msg);
        const ErrorsContainer &errors() const;

        void O3PRM();
        void Package();
        void Import();
        void Unit();
        void Ident(std::string &s);
        void ImportIdent(std::string &s);
        void Type();
        void Interface();
        void Class();
        void System();
        void Label(std::string &s);
        void Reference(std::string type, std::string name, bool array);
        void RefOrParam(std::string type, std::string name, bool array);
        void Attribute(std::string type, std::string name);
        void Aggregate(std::string type, std::string name);
        void Functions(std::string type, std::string name);
        void Parameter(std::string type, std::string name);
        void CastIdent(std::string &s);
        void Number(float &val);
        void CPTRule(bool &error);
        void CPTRuleValue(std::string &s);
        void AggChains(std::vector<std::string> &chains);
        void AggLabels(std::vector<std::string> &labels);
        void NumberList(std::vector<float> &numbers);
        void ArrayDecl(std::string l1);

        void Parse();

      }; // end Parser

    } // namespace
  }   // namespace
} // namespace

#endif // !defined(COCO_PARSER_H__)
