/*----------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than
  Coco/R itself) does not fall under the GNU General Public License.
  -----------------------------------------------------------------------*/

-- > begin

#ifndef PRM_RUN_COCO_SCANNER_H__
#define PRM_RUN_COCO_SCANNER_H__

#include <agrum/core/cocoR.h>
#

using namespace gum;

-- > namespace_open

class Token {
  public:
    int kind;     // token kind
    int pos;      // token position in the source text (starting at 0)
    int col;      // token column (starting at 1)
    int line;     // token line (starting at 1)
    wchar_t* val; // token value
    Token* next;  // ML 2005-03-11 Peek tokens are kept in linked list

    Token();
    ~Token();
};

class Buffer {
    // This Buffer supports the following cases:
    // 1) seekable stream (file)
    //    a) whole stream in buffer
    //    b) part of stream in buffer
    // 2) non seekable stream (network, console)
  private:
    unsigned char* buf; // input buffer
    int bufCapacity;    // capacity of buf
    int bufStart;       // position of first byte in buffer relative to input stream
    int bufLen;         // length of buffer
    int fileLen;        // length of input stream (may change if the stream is no file)
    int bufPos;         // current position in buffer
    FILE* stream;       // input stream (seekable)
    bool isUserStream;  // was the stream opened by the user?

    int ReadNextStreamChunk();
    bool CanSeek();     // true if stream can be seeked otherwise false

  public:
    static const int EoF = COCO_WCHAR_MAX + 1;

    Buffer ( FILE* s, bool isUserStream );
    Buffer ( const unsigned char* buf, int len );
    Buffer ( Buffer* b );
    virtual ~Buffer();

    virtual void Close();
    virtual int Read();
    virtual int Peek();
    virtual wchar_t* GetString ( int beg, int end );
    virtual int GetPos();
    virtual void SetPos ( int value );
};

class UTF8Buffer : public Buffer {
  public:
    UTF8Buffer ( Buffer* b ) : Buffer ( b ) {};
    virtual int Read();
};

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates {
  private:
    class Elem {
      public:
        int key, val;
        Elem* next;
        Elem ( int key, int val ) { this->key = key; this->val = val; next = NULL; }
    };

    Elem** tab;

  public:
    StartStates() { tab = new Elem*[128]; memset ( tab, 0, 128 * sizeof ( Elem* ) ); }
    virtual ~StartStates() {
      for ( int i = 0; i < 128; ++i ) {
        Elem* e = tab[i];

        while ( e != NULL ) {
          Elem* next = e->next;
          delete e;
          e = next;
        }
      }

      delete [] tab;
    }

    void set ( int key, int val ) {
      Elem* e = new Elem ( key, val );
      int k = ( ( unsigned int ) key ) % 128;
      e->next = tab[k]; tab[k] = e;
    }

    int state ( int key ) {
      Elem* e = tab[ ( ( unsigned int ) key ) % 128];

      while ( e != NULL && e->key != key ) e = e->next;

      return e == NULL ? 0 : e->val;
    }
};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap {
  private:
    class Elem {
      public:
        wchar_t* key;
        int val;
        Elem* next;
        Elem ( const wchar_t* key, int val ) { this->key = gum::coco_string_create ( key ); this->val = val; next = NULL; }
        virtual ~Elem() { gum::coco_string_delete ( key ); }
    };

    Elem** tab;

  public:
    KeywordMap() { tab = new Elem*[128]; memset ( tab, 0, 128 * sizeof ( Elem* ) ); }
    virtual ~KeywordMap() {
      for ( int i = 0; i < 128; ++i ) {
        Elem* e = tab[i];

        while ( e != NULL ) {
          Elem* next = e->next;
          delete e;
          e = next;
        }
      }

      delete [] tab;
    }

    void set ( const wchar_t* key, int val ) {
      Elem* e = new Elem ( key, val );
      int k = gum::coco_string_hash ( key ) % 128;
      e->next = tab[k]; tab[k] = e;
    }

    int get ( const wchar_t* key, int defaultVal ) {
      Elem* e = tab[gum::coco_string_hash ( key ) % 128];

      while ( e != NULL && !gum::coco_string_equal ( e->key, key ) ) e = e->next;

      return e == NULL ? defaultVal : e->val;
    }
};

class Scanner {
  private:
    void* firstHeap;
    void* heap;
    void* heapTop;
    void** heapEnd;

    unsigned char EOL;
    int eofSym;
    int noSym;
    int maxT;
    int charSetSize;
    StartStates start;
    KeywordMap keywords;

    Token* t;         // current token
    wchar_t* tval;    // text of current token
    int tvalLength;   // length of text of current token
    int tlen;         // length of current token

    Token* tokens;    // list of tokens already peeked (first token is a dummy)
    Token* pt;        // current peek token

    int ch;           // current input character
    -- > casing0
    int pos;          // byte position of current character
    int line;         // line number of current character
    int col;          // column number of current character
    int oldEols;      // EOLs that appeared in a comment;

    void CreateHeapBlock();
    Token* CreateToken();
    void AppendVal ( Token* t );

    void Init();
    void NextCh();
    void AddCh();
    -- > commentsheader
    Token* NextToken();

  public:
    Buffer* buffer;   // scanner buffer

    Scanner ( std::string filename );
    ~Scanner();
    Token* Scan();
    Token* Peek();
    void ResetPeek();
    std::string filename;

}; // end Scanner

-- > namespace_close

#endif // !defined(SKOOL_COCO_SCANNER_H__)

-- > implementation
/*-------------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than
  Coco/R itself) does not fall under the GNU General Public License.
  -------------------------------------------------------------------------*/
-- > begin

#include "Scanner.h"

-- > namespace_open

Token::Token() {
  kind = 0;
  pos  = 0;
  col  = 0;
  line = 0;
  val  = NULL;
  next = NULL;
}

Token::~Token() {
  gum::coco_string_delete ( val );
}

Buffer::Buffer ( FILE* s, bool isUserStream ) {
  // ensure binary read on windows
#if _MSC_VER >= 1300
  _setmode ( _fileno ( s ), _O_BINARY );
#endif
  stream = s; this->isUserStream = isUserStream;

  if ( CanSeek() ) {
    fseek ( s, 0, SEEK_END );
    fileLen = ftell ( s );
    fseek ( s, 0, SEEK_SET );
    bufLen = ( fileLen < MAX_BUFFER_LENGTH ) ? fileLen : MAX_BUFFER_LENGTH;
    bufStart = INT_MAX; // nothing in the buffer so far
  } else {
    fileLen = bufLen = bufStart = 0;
  }

  bufCapacity = ( bufLen > 0 ) ? bufLen : MIN_BUFFER_LENGTH;
  buf = new unsigned char[bufCapacity];

  if ( fileLen > 0 ) SetPos ( 0 );     // setup  buffer to position 0 (start)
  else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid

  if ( bufLen == fileLen && CanSeek() ) Close();
}

Buffer::Buffer ( Buffer* b ) {
  buf = b->buf;
  bufCapacity = b->bufCapacity;
  b->buf = NULL;
  bufStart = b->bufStart;
  bufLen = b->bufLen;
  fileLen = b->fileLen;
  bufPos = b->bufPos;
  stream = b->stream;
  b->stream = NULL;
  isUserStream = b->isUserStream;
}

Buffer::Buffer ( const unsigned char* buf, int len ) {
  this->buf = new unsigned char[len];
  memcpy ( this->buf, buf, len * sizeof ( unsigned char ) );
  bufStart = 0;
  bufCapacity = bufLen = len;
  fileLen = len;
  bufPos = 0;
  stream = NULL;
}

Buffer::~Buffer() {
  Close();

  if ( buf != NULL ) {
    delete [] buf;
    buf = NULL;
  }
}

void Buffer::Close() {
  if ( !isUserStream && stream != NULL ) {
    fclose ( stream );
    stream = NULL;
  }
}

int Buffer::Read() {
  if ( bufPos < bufLen ) {
    return buf[bufPos++];
  } else if ( GetPos() < fileLen ) {
    SetPos ( GetPos() ); // shift buffer start to Pos
    return buf[bufPos++];
  } else if ( ( stream != NULL ) && !CanSeek() && ( ReadNextStreamChunk() > 0 ) ) {
    return buf[bufPos++];
  } else {
    return EoF;
  }
}

int Buffer::Peek() {
  int curPos = GetPos();
  int ch = Read();
  SetPos ( curPos );
  return ch;
}

wchar_t* Buffer::GetString ( int beg, int end ) {
  int len = end - beg;
  wchar_t* buf = new wchar_t[len];
  int oldPos = GetPos();
  SetPos ( beg );

  for ( int i = 0; i < len; ++i ) buf[i] = ( wchar_t ) Read();

  SetPos ( oldPos );
  return buf;
}

int Buffer::GetPos() {
  return bufPos + bufStart;
}

void Buffer::SetPos ( int value ) {
  if ( ( value >= fileLen ) && ( stream != NULL ) && !CanSeek() ) {
    // Wanted position is after buffer and the stream
    // is not seek-able e.g. network or console,
    // thus we have to read the stream manually till
    // the wanted position is in sight.
    while ( ( value >= fileLen ) && ( ReadNextStreamChunk() > 0 ) );
  }

  if ( ( value < 0 ) || ( value > fileLen ) ) {
    wprintf ( L"--- buffer out of bounds access, position: %d\n", value );
    exit ( 1 );
  }

  if ( ( value >= bufStart ) && ( value < ( bufStart + bufLen ) ) ) { // already in buffer
    bufPos = value - bufStart;
  } else if ( stream != NULL ) { // must be swapped in
    fseek ( stream, value, SEEK_SET );
    bufLen = fread ( buf, sizeof ( unsigned char ), bufCapacity, stream );
    bufStart = value; bufPos = 0;
  } else {
    bufPos = fileLen - bufStart; // make Pos return fileLen
  }
}

// Read the next chunk of bytes from the stream, increases the buffer
// if needed and updates the fields fileLen and bufLen.
// Returns the number of bytes read.
int Buffer::ReadNextStreamChunk() {
  int free = bufCapacity - bufLen;

  if ( free == 0 ) {
    // in the case of a growing input stream
    // we can neither seek in the stream, nor can we
    // foresee the maximum length, thus we must adapt
    // the buffer size on demand.
    bufCapacity = bufLen * 2;
    unsigned char* newBuf = new unsigned char[bufCapacity];
    memcpy ( newBuf, buf, bufLen * sizeof ( unsigned char ) );
    delete [] buf;
    buf = newBuf;
    free = bufLen;
  }

  int read = fread ( buf + bufLen, sizeof ( unsigned char ), free, stream );

  if ( read > 0 ) {
    fileLen = bufLen = ( bufLen + read );
    return read;
  }

  // end of stream reached
  return 0;
}

bool Buffer::CanSeek() {
  return ( stream != NULL ) && ( ftell ( stream ) != -1 );
}

int UTF8Buffer::Read() {
  int ch;

  do {
    ch = Buffer::Read();
    // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
  } while ( ( ch >= 128 ) && ( ( ch & 0xC0 ) != 0xC0 ) && ( ch != EoF ) );

  if ( ch < 128 || ch == EoF ) {
    // nothing to do, first 127 chars are the same in ascii and utf8
    // 0xxxxxxx or end of file character
  } else if ( ( ch & 0xF0 ) == 0xF0 ) {
    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    int c1 = ch & 0x07; ch = Buffer::Read();
    int c2 = ch & 0x3F; ch = Buffer::Read();
    int c3 = ch & 0x3F; ch = Buffer::Read();
    int c4 = ch & 0x3F;
    ch = ( ( ( ( ( c1 << 6 ) | c2 ) << 6 ) | c3 ) << 6 ) | c4;
  } else if ( ( ch & 0xE0 ) == 0xE0 ) {
    // 1110xxxx 10xxxxxx 10xxxxxx
    int c1 = ch & 0x0F; ch = Buffer::Read();
    int c2 = ch & 0x3F; ch = Buffer::Read();
    int c3 = ch & 0x3F;
    ch = ( ( ( c1 << 6 ) | c2 ) << 6 ) | c3;
  } else if ( ( ch & 0xC0 ) == 0xC0 ) {
    // 110xxxxx 10xxxxxx
    int c1 = ch & 0x1F; ch = Buffer::Read();
    int c2 = ch & 0x3F;
    ch = ( c1 << 6 ) | c2;
  }

  return ch;
}

Scanner::Scanner ( std::string file ) :
  filename ( file ) {
  FILE* stream;
  char* chFileName = gum::coco_string_create_char ( widen ( file ).c_str() );

  if ( ( stream = fopen ( chFileName, "rb" ) ) == NULL ) {
    wprintf ( L"--- Cannot open file %s\n", file.c_str() );
    exit ( 1 );
  }

  gum::coco_string_delete ( chFileName );
  buffer = new Buffer ( stream, false );
  Init();
}

Scanner::~Scanner() {
  char* cur = ( char* ) firstHeap;

  while ( cur != NULL ) {
    cur = * ( char** ) ( cur + HEAP_BLOCK_SIZE );
    free ( firstHeap );
    firstHeap = cur;
  }

  delete [] tval;
  delete buffer;
}

void Scanner::Init() {
  EOL    = '\n';
  eofSym = 0;
  -- > declarations

  tvalLength = 128;
  tval = new wchar_t[tvalLength]; // text of current token

  // HEAP_BLOCK_SIZE byte heap + pointer to next heap block
  heap = malloc ( HEAP_BLOCK_SIZE + sizeof ( void* ) );
  firstHeap = heap;
  heapEnd = ( void** ) ( ( ( char* ) heap ) + HEAP_BLOCK_SIZE );
  *heapEnd = 0;
  heapTop = heap;

  if ( sizeof ( Token ) > HEAP_BLOCK_SIZE ) {
    wprintf ( L"--- Too small HEAP_BLOCK_SIZE\n" );
    exit ( 1 );
  }

  pos = -1; line = 1; col = 0;
  oldEols = 0;
  NextCh();

  if ( ch == 0xEF ) { // check optional byte order mark for UTF-8
    NextCh(); int ch1 = ch;
    NextCh(); int ch2 = ch;

    if ( ch1 != 0xBB || ch2 != 0xBF ) {
      wprintf ( L"Illegal byte order mark at start of file" );
      exit ( 1 );
    }

    Buffer* oldBuf = buffer;
    buffer = new UTF8Buffer ( buffer ); col = 0;
    delete oldBuf; oldBuf = NULL;
    NextCh();
  }

  -- > initialization
  pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh() {
  if ( oldEols > 0 ) { ch = EOL; oldEols--; }
  else {
    pos = buffer->GetPos();
    ch = buffer->Read(); col++;

    // replace isolated '\r' by '\n' in order to make
    // eol handling uniform across Windows, Unix and Mac
    if ( ch == L'\r' && buffer->Peek() != L'\n' ) ch = EOL;

    if ( ch == EOL ) { line++; col = 0; }
  }

  -- > casing1
}

void Scanner::AddCh() {
  if ( tlen >= tvalLength ) {
    tvalLength *= 2;
    wchar_t* newBuf = new wchar_t[tvalLength];
    memcpy ( newBuf, tval, tlen * sizeof ( wchar_t ) );
    delete [] tval;
    tval = newBuf;
  }

  if ( ch != Buffer::EoF ) {
    -- > casing2
    NextCh();
  }
}

-- > comments

void Scanner::CreateHeapBlock() {
  void* newHeap;
  char* cur = ( char* ) firstHeap;

  while ( ( ( char* ) tokens < cur ) || ( ( char* ) tokens > ( cur + HEAP_BLOCK_SIZE ) ) ) {
    cur = * ( ( char** ) ( cur + HEAP_BLOCK_SIZE ) );
    free ( firstHeap );
    firstHeap = cur;
  }

  // HEAP_BLOCK_SIZE byte heap + pointer to next heap block
  newHeap = malloc ( HEAP_BLOCK_SIZE + sizeof ( void* ) );
  *heapEnd = newHeap;
  heapEnd = ( void** ) ( ( ( char* ) newHeap ) + HEAP_BLOCK_SIZE );
  *heapEnd = 0;
  heap = newHeap;
  heapTop = heap;
}

Token* Scanner::CreateToken() {
  Token* t;

  if ( ( ( char* ) heapTop + ( int ) sizeof ( Token ) ) >= ( char* ) heapEnd ) {
    CreateHeapBlock();
  }

  t = ( Token* ) heapTop;
  heapTop = ( void* ) ( ( char* ) heapTop + sizeof ( Token ) );
  t->val = NULL;
  t->next = NULL;
  return t;
}

void Scanner::AppendVal ( Token* t ) {
  int reqMem = ( tlen + 1 ) * sizeof ( wchar_t );

  if ( ( ( char* ) heapTop + reqMem ) >= ( char* ) heapEnd ) {
    if ( reqMem > HEAP_BLOCK_SIZE ) {
      wprintf ( L"--- Too long token value\n" );
      exit ( 1 );
    }

    CreateHeapBlock();
  }

  t->val = ( wchar_t* ) heapTop;
  heapTop = ( void* ) ( ( char* ) heapTop + reqMem );

  wcsncpy ( t->val, tval, tlen );
  t->val[tlen] = L'\0';
}

Token* Scanner::NextToken() {
  while ( ch == ' ' ||
          -- > scan1
        ) NextCh();

  -- > scan2
  t = CreateToken();
  t->pos = pos; t->col = col; t->line = line;
  int state = start.state ( ch );
  tlen = 0; AddCh();

  switch ( state ) {
    case -1: { t->kind = eofSym; break; } // NextCh already done

    case 0: { t->kind = noSym; break; }   // NextCh already done

      -- > scan3
  }

  AppendVal ( t );
  return t;
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan() {
  if ( tokens->next == NULL ) {
    return pt = tokens = NextToken();
  } else {
    pt = tokens = tokens->next;
    return tokens;
  }
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek() {
  do {
    if ( pt->next == NULL ) {
      pt->next = NextToken();
    }

    pt = pt->next;
  } while ( pt->kind > maxT ); // skip pragmas

  return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek() {
  pt = tokens;
}

-- > namespace_close

$$$

