/*-------------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than
  Coco/R itself) does not fall under the GNU General Public License.
  -------------------------------------------------------------------------*/

-->begin

#ifndef PRM_RUN_COCO_PARSER_H__
#define PRM_RUN_COCO_PARSER_H__

-->headerdef

#include <agrum/core/exceptions.h>
#include <agrum/core/timer.h>
#include <agrum/BN/inference/BayesNetInference.h>
#include <agrum/BN/inference/variableElimination.h>
#include <agrum/BN/inference/VEWithBB.h>
#include <agrum/BN/inference/ShaferShenoyInference.h>
#include <agrum/BN/inference/lazyPropagation.h>
#include <agrum/BN/inference/BayesNetInference.h>
#include <agrum/BN/inference/BayesNetInference.h>
#include <agrum/prm/PRMInference.h>
#include <agrum/prm/SVE.h>
#include <agrum/prm/SVED.h>
#include <agrum/prm/groundedInference.h>
#include <agrum/prm/skool/SkoolReader.h>

#include "Scanner.h"

using namespace gum;

-->namespace_open

class Errors {
  public:
    // number of errors detected
    int count;
    Errors();
    void SynErr ( std::string file, int line, int n );
    void Warning ( std::string file, int line, const wchar_t* s );
    void Error ( std::string file, int line, const wchar_t* s );
}; // Errors

class Parser {
  private:

    -->constantsheader

    Token* dummyToken;
    int errDist;
    int minErrDist;

    void SynErr ( int n );
    void Get();
    void Expect ( int n );
    bool StartOf ( int s );
    void ExpectWeak ( int n, int follow );
    bool WeakSeparator ( int n, int syFol, int repFol );

    bool __syntax_flag;

  public:
    Scanner* scanner;
    Errors*  errors;

    Token* t;  // last recognized token
    Token* la; // lookahead token

    -->declarations

    Parser ( Scanner* scanner, std::ostream& out = std::cout );
    ~Parser();
    void warning ( const std::string& s );
    void error ( const std::string& s );

    -->productionsheader

    void Parse();

    // My stuff
    gum::prm::skool::SkoolReader reader;
    std::string package;
    std::string file_name;
    std::string query_name;
    std::string engine;
    std::string bn_engine;
    gum::prm::PRMInference* inf;
    bool verbose;
    std::ostream& log;
    // We need this when using grounded inference
    gum::BayesNetInference<gum::prm::prm_float>* bn;

    void import ( std::string import_name );
    std::string findSystemName ( const std::string& s );
    std::string findInstanceName ( const std::string& s, const std::string& sys );
    std::string findAttributeName ( const std::string& s, const gum::prm::Instance& instance );
    void addObservation ( const std::string& left_val, const std::string& right_val );
    void removeObervation ( const std::string name );
    void generateInfEngine ( const gum::prm::System& sys );
    void query ( const std::string& name );
    bool isInSyntaxMode() const;
    void setSyntaxMode ( bool f );
}; // end Parser

-->namespace_close

#endif // !defined(SKOOL_COCO_PARSER_H__)

-->implementation

/*----------------------------------------------------------------------
  Compiler Generator Coco/R,
  Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
  extended by M. Loeberbauer & A. Woess, Univ. of Linz
  ported to C++ by Csaba Balazs, University of Szeged
  with improvements by Pat Terry, Rhodes University

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  As an exception, it is allowed to write an extension of Coco/R that is
  used as a plugin in non-free software.

  If not otherwise stated, any source code generated by Coco/R (other than
  Coco/R itself) does not fall under the GNU General Public License.
  -----------------------------------------------------------------------*/
-->begin

#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"

-->namespace_open

void Parser::SynErr ( int n ) {
  if ( errDist >= minErrDist ) errors->SynErr ( scanner->filename, la->line, n );

  errDist = 0;
}

void Parser::warning ( const std::string& s ) {
  errors->Warning ( scanner->filename, t->line, gum::widen ( s ).c_str() );
}

void Parser::error ( const std::string& s ) {
  if ( errDist >= minErrDist ) errors->Error ( scanner->filename, t->line, gum::widen ( s ).c_str() );

  errDist = 0;
}

void Parser::Get() {
  for ( ;; ) {
    t = la;
    la = scanner->Scan();
    if (la->kind <= maxT) { ++errDist; break; }

    -->pragmas

      if (dummyToken != t) {
        dummyToken->kind = t->kind;
        dummyToken->pos = t->pos;
        dummyToken->col = t->col;
        dummyToken->line = t->line;
        dummyToken->next = NULL;
        gum::coco_string_delete(dummyToken->val);
        dummyToken->val = gum::coco_string_create(t->val);
        t = dummyToken;
      }
    la = t;
  }
}

void Parser::Expect ( int n ) {
  if ( la->kind == n ) Get(); else { SynErr ( n ); }
}

void Parser::ExpectWeak ( int n, int follow ) {
  if ( la->kind == n ) Get();
  else {
    SynErr ( n );

    while ( !StartOf ( follow ) ) Get();
  }
}

bool Parser::WeakSeparator ( int n, int syFol, int repFol ) {
  if ( la->kind == n ) {Get(); return true;}
  else if ( StartOf ( repFol ) ) {return false;}
  else {
    SynErr ( n );

    while ( ! ( StartOf ( syFol ) || StartOf ( repFol ) || StartOf ( 0 ) ) ) {
      Get();
    }

    return StartOf ( syFol );
  }
}

-->productions

void Parser::Parse() {
  t = NULL;
  la = dummyToken = new Token();
  la->val = gum::coco_string_create ( L"Dummy Token" );
  Get();

  -->parseRoot

  Expect ( 0 );
}

Parser::Parser ( Scanner* scanner, std::ostream& out ) :
  log ( out ), __syntax_flag ( false ) {
  -- > constants

  dummyToken = NULL;
  t = la = NULL;
  minErrDist = 2;
  errDist = minErrDist;
  this->scanner = scanner;
  errors = new Errors();
}

bool Parser::StartOf ( int s ) {
  const bool T = true;
  const bool x = false;

  -->initialization

  return set[s][la->kind];
}

Parser::~Parser() {
  delete errors;
  delete dummyToken;
}

Errors::Errors() {
  count = 0;
}

void Errors::SynErr ( std::string filename, int line, int n ) {
  wchar_t* s;
  switch (n) {

    -->errors

    default:
    {
      wchar_t format[20];
      coco_swprintf ( format, 20, L"error %d", n );
      s = gum::coco_string_create ( format );
    }
    break;
  }

  wprintf ( L"%s|%d| syntax error: %ls\n", filename.c_str(), line, s );
  gum::coco_string_delete ( s );
  count++;
}

void Errors::Warning ( std::string filename, int line, const wchar_t* s ) {
  wprintf ( L"%s|%d| warning: %ls\n", filename.c_str(), line, s );
}

void Errors::Error ( std::string filename, int line, const wchar_t* s ) {
  wprintf ( L"%s|%d| error: %ls\n", filename.c_str(), line, s );
  count++;
}

void Parser::import ( std::string import_name ) {
  if ( verbose ) {
    log << "Loading system " << import_name << "... " << std::flush;
  }

  std::replace ( import_name.begin(), import_name.end(), '.', '/' );
  std::string ext = ".skool";
  reader.readFile ( import_name + ext );

  if ( verbose ) {
    log << "Finished." << std::endl;
  }
}

std::string Parser::findSystemName ( const std::string& s ) {
  std::string name;
  size_t dot = s.find_first_of ( '.' );

  while ( dot != std::string::npos ) {
    name = s.substr ( 0, dot );

    if ( reader.prm()->isSystem ( name ) ) return name;

    dot = s.find ( '.', dot + 1 );
  }

  std::string msg = "could not find any system in ";
  error ( msg + s );
  throw msg + s;
}

std::string Parser::findInstanceName ( const std::string& s, const std::string& sys ) {
  std::string name = s.substr ( sys.length() + 1 );
  size_t dot = name.find ( '.' );
  name = name.substr ( 0, dot );

  if ( reader.prm()->getSystem ( sys ).exists ( name ) ) return name;

  std::string msg = "could not find any instance in ";
  error ( msg + name );
  throw msg + name;
}

std::string Parser::findAttributeName ( const std::string& s, const gum::prm::Instance& instance ) {
  size_t dot = s.find_last_of ( '.' );

  if ( dot != std::string::npos ) {
    std::string name = s.substr ( dot + 1, std::string::npos );

    if ( instance.exists ( name ) ) return name;
  }

  std::string msg = "could not find any attribute in ";
  error ( msg + s );
  throw msg + s;
}

void Parser::addObservation ( const std::string& left_val, const std::string& right_val ) {
  const gum::prm::System& sys = reader.prm()->getSystem ( findSystemName ( left_val ) );
  const gum::prm::Instance& instance = sys.get ( findInstanceName ( left_val, sys.name() ) );
  const gum::prm::Attribute& attr = instance.get ( findAttributeName ( left_val, instance ) );
  gum::prm::PRMInference::Chain chain = std::make_pair ( &instance, &attr );

  if ( not inf ) {
    generateInfEngine ( sys );
  }

  if ( inf->hasEvidence ( chain ) ) {
    std::string msg = " is already observed";
    warning ( left_val + msg );
  }

  gum::Potential<gum::prm::prm_float> e;
  e.add ( chain.second->type().variable() );
  gum::Instantiation i ( e );
  bool found = false;

  for ( i.setFirst(); not i.end(); i.inc() ) {
    if ( chain.second->type().variable().label ( i.val ( chain.second->type().variable() ) ) == right_val ) {
      e.set ( i, ( gum::prm::prm_float ) 1.0 );
      found = true;
    } else {
      e.set ( i, ( gum::prm::prm_float ) 0.0 );
    }
  }

  if ( not found ) {
    std::string msg = " is not a label of ";
    error ( right_val + msg + left_val );
    throw right_val + msg + left_val;
  }

  try {
    inf->addEvidence ( chain, e );

    //affichage en demande
    if ( verbose ) {
      log << "Added evidence " << right_val << " over attribute " << left_val << std::endl;
    }
  } catch ( gum::OperationNotAllowed& ex ) {
    std::stringstream sBuff;
    sBuff << " someting went wrong when adding evidence " << right_val;
    sBuff << " over " << left_val;
    error ( sBuff.str() );
    throw sBuff.str();
  }
}

void Parser::removeObervation ( const std::string name ) {
  const gum::prm::System& sys = reader.prm()->getSystem ( findSystemName ( name ) );
  const gum::prm::Instance& instance = sys.get ( findInstanceName ( name, sys.name() ) );
  const gum::prm::Attribute& attr = instance.get ( findAttributeName ( name, instance ) );
  gum::prm::PRMInference::Chain chain = std::make_pair ( &instance, &attr );

  if ( inf->hasEvidence ( chain ) ) {
    inf->removeEvidence ( chain );

    if ( verbose ) {
      log << "Removed evidence over attribute " << name << std::endl;
    }
  } else {
    std::string msg = " was not observed";
    warning ( name + msg );
  }
}

void Parser::generateInfEngine ( const gum::prm::System& sys ) {
  if ( inf ) {
    warning ( "an inference engine has already been defined" );
    delete inf;
  }

  if ( engine == "SVED" ) {
    inf = new gum::prm::SVED ( * ( reader.prm() ), sys );
  } else if ( engine == "GRD" ) {
    typedef gum::prm::prm_float p_f;
    gum::BayesNetInference<p_f>* bn_inf = 0;
    gum::BayesNet<p_f>* bn = new gum::BayesNet<p_f>();
    gum::BayesNetFactory<p_f> bn_factory ( bn );

    if ( verbose ) {
      log << "Grounding the network... " << std::flush;
    }

    sys.groundedBN ( bn_factory );

    if ( verbose ) {
      log << "Finished." << std::endl;
    }

    if ( bn_engine == "VE" ) {
      bn_inf = new gum::VariableElimination<p_f> ( *bn );
    } else if ( bn_engine == "VEBB" ) {
      bn_inf = new gum::VEWithBB<p_f> ( *bn );
    } else if ( bn_engine == "lazy" ) {
      bn_inf = new gum::LazyPropagation<p_f> ( *bn );
    } else {
      bn_inf = new gum::ShaferShenoyInference<p_f> ( *bn );
    }

    gum::prm::GroundedInference* grd_inf = new gum::prm::GroundedInference ( * ( reader.prm() ), sys );
    grd_inf->setBNInference ( bn_inf );
    inf = grd_inf;
  } else {
    inf = new gum::prm::SVE ( * ( reader.prm() ), sys );
  }
}

void Parser::query ( const std::string& name ) {
  if ( not isInSyntaxMode() ) {
    const gum::prm::System& sys = reader.prm()->getSystem ( findSystemName ( name ) );
    const gum::prm::Instance& instance = sys.get ( findInstanceName ( name, sys.name() ) );
    const gum::prm::Attribute& attr = instance.get ( findAttributeName ( name, instance ) );
    gum::prm::PRMInference::Chain chain = std::make_pair ( &instance, &attr );
    gum::Potential<gum::prm::prm_float> m;

    for ( size_t i = 0; i < 80; ++i ) {
      log << "#";
    }

    log << std::endl;

    if ( not inf ) {
      log << "Building the inference engine... " << std::flush;
      generateInfEngine ( sys );
      log << "Finished." << std::endl;
    }

    try {
      gum::Timer timer;
      timer.reset();
      log << "Starting inference over query: " << name << "... " << std::flush;
      inf->marginal ( chain, m );
      log << "Finished." << std::endl;
      double t = timer.step();
      log << "Time in seconds (accuracy ~0.001): " << t << std::endl;
    } catch ( gum::Exception& e ) {
      std::string msg = "something went wrong while infering: ";
      error ( msg + e.getContent() );
      delete inf;
      throw msg + e.getContent();
    }

    gum::Instantiation j ( m );

    for ( j.setFirst (); not j.end (); j.inc () ) {
      log << attr.type().variable().label ( j.val ( attr.type().variable() ) ) << ": " << m.get ( j ) << std::endl;
    }

    for ( size_t i = 0; i < 80; ++i ) {
      log << "#";
    }

    log << std::endl << std::endl;
    delete inf;
  }
}

bool Parser::isInSyntaxMode() const {
  return __syntax_flag;
}

void Parser::setSyntaxMode ( bool f ) {
  __syntax_flag = f;
}

-->namespace_close

$$$

